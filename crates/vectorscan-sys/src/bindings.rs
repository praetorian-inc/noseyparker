/* automatically generated by rust-bindgen 0.64.0 */

pub const HS_MAJOR: u32 = 5;
pub const HS_MINOR: u32 = 4;
pub const HS_PATCH: u32 = 0;
pub const HS_SUCCESS: u32 = 0;
pub const HS_INVALID: i32 = -1;
pub const HS_NOMEM: i32 = -2;
pub const HS_SCAN_TERMINATED: i32 = -3;
pub const HS_COMPILER_ERROR: i32 = -4;
pub const HS_DB_VERSION_ERROR: i32 = -5;
pub const HS_DB_PLATFORM_ERROR: i32 = -6;
pub const HS_DB_MODE_ERROR: i32 = -7;
pub const HS_BAD_ALIGN: i32 = -8;
pub const HS_BAD_ALLOC: i32 = -9;
pub const HS_SCRATCH_IN_USE: i32 = -10;
pub const HS_ARCH_ERROR: i32 = -11;
pub const HS_INSUFFICIENT_SPACE: i32 = -12;
pub const HS_UNKNOWN_ERROR: i32 = -13;
pub const HS_EXT_FLAG_MIN_OFFSET: u32 = 1;
pub const HS_EXT_FLAG_MAX_OFFSET: u32 = 2;
pub const HS_EXT_FLAG_MIN_LENGTH: u32 = 4;
pub const HS_EXT_FLAG_EDIT_DISTANCE: u32 = 8;
pub const HS_EXT_FLAG_HAMMING_DISTANCE: u32 = 16;
pub const HS_FLAG_CASELESS: u32 = 1;
pub const HS_FLAG_DOTALL: u32 = 2;
pub const HS_FLAG_MULTILINE: u32 = 4;
pub const HS_FLAG_SINGLEMATCH: u32 = 8;
pub const HS_FLAG_ALLOWEMPTY: u32 = 16;
pub const HS_FLAG_UTF8: u32 = 32;
pub const HS_FLAG_UCP: u32 = 64;
pub const HS_FLAG_PREFILTER: u32 = 128;
pub const HS_FLAG_SOM_LEFTMOST: u32 = 256;
pub const HS_FLAG_COMBINATION: u32 = 512;
pub const HS_FLAG_QUIET: u32 = 1024;
pub const HS_CPU_FEATURES_AVX2: u32 = 4;
pub const HS_CPU_FEATURES_AVX512: u32 = 8;
pub const HS_CPU_FEATURES_AVX512VBMI: u32 = 16;
pub const HS_TUNE_FAMILY_GENERIC: u32 = 0;
pub const HS_TUNE_FAMILY_SNB: u32 = 1;
pub const HS_TUNE_FAMILY_IVB: u32 = 2;
pub const HS_TUNE_FAMILY_HSW: u32 = 3;
pub const HS_TUNE_FAMILY_SLM: u32 = 4;
pub const HS_TUNE_FAMILY_BDW: u32 = 5;
pub const HS_TUNE_FAMILY_SKL: u32 = 6;
pub const HS_TUNE_FAMILY_SKX: u32 = 7;
pub const HS_TUNE_FAMILY_GLM: u32 = 8;
pub const HS_TUNE_FAMILY_ICL: u32 = 9;
pub const HS_TUNE_FAMILY_ICX: u32 = 10;
pub const HS_MODE_BLOCK: u32 = 1;
pub const HS_MODE_NOSTREAM: u32 = 1;
pub const HS_MODE_STREAM: u32 = 2;
pub const HS_MODE_VECTORED: u32 = 4;
pub const HS_MODE_SOM_HORIZON_LARGE: u32 = 16777216;
pub const HS_MODE_SOM_HORIZON_MEDIUM: u32 = 33554432;
pub const HS_MODE_SOM_HORIZON_SMALL: u32 = 67108864;
pub const HS_OFFSET_PAST_HORIZON: i32 = -1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_database {
    _unused: [u8; 0],
}
#[doc = " A Hyperscan pattern database.\n\n Generated by one of the Hyperscan compiler functions:\n  - @ref hs_compile()\n  - @ref hs_compile_multi()\n  - @ref hs_compile_ext_multi()"]
pub type hs_database_t = hs_database;
#[doc = " A type for errors returned by Hyperscan functions."]
pub type hs_error_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Free a compiled pattern database.\n\n The free callback set by @ref hs_set_database_allocator() (or @ref\n hs_set_allocator()) will be used by this function.\n\n @param db\n      A compiled pattern database. NULL may also be safely provided, in which\n      case the function does nothing.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_free_database(db: *mut hs_database_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Serialize a pattern database to a stream of bytes.\n\n The allocator callback set by @ref hs_set_misc_allocator() (or @ref\n hs_set_allocator()) will be used by this function.\n\n @param db\n      A compiled pattern database.\n\n @param bytes\n      On success, a pointer to an array of bytes will be returned here.\n      These bytes can be subsequently relocated or written to disk. The\n      caller is responsible for freeing this block.\n\n @param length\n      On success, the number of bytes in the generated byte array will be\n      returned here.\n\n @return\n      @ref HS_SUCCESS on success, @ref HS_NOMEM if the byte array cannot be\n      allocated, other values may be returned if errors are detected."]
    pub fn hs_serialize_database(
        db: *const hs_database_t,
        bytes: *mut *mut ::std::os::raw::c_char,
        length: *mut usize,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Reconstruct a pattern database from a stream of bytes previously generated\n by @ref hs_serialize_database().\n\n This function will allocate sufficient space for the database using the\n allocator set with @ref hs_set_database_allocator() (or @ref\n hs_set_allocator()); to use a pre-allocated region of memory, use the @ref\n hs_deserialize_database_at() function.\n\n @param bytes\n      A byte array generated by @ref hs_serialize_database() representing a\n      compiled pattern database.\n\n @param length\n      The length of the byte array generated by @ref hs_serialize_database().\n      This should be the same value as that returned by @ref\n      hs_serialize_database().\n\n @param db\n      On success, a pointer to a newly allocated @ref hs_database_t will be\n      returned here. This database can then be used for scanning, and\n      eventually freed by the caller using @ref hs_free_database().\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_deserialize_database(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        db: *mut *mut hs_database_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Reconstruct a pattern database from a stream of bytes previously generated\n by @ref hs_serialize_database() at a given memory location.\n\n This function (unlike @ref hs_deserialize_database()) will write the\n reconstructed database to the memory location given in the @p db parameter.\n The amount of space required at this location can be determined with the\n @ref hs_serialized_database_size() function.\n\n @param bytes\n      A byte array generated by @ref hs_serialize_database() representing a\n      compiled pattern database.\n\n @param length\n      The length of the byte array generated by @ref hs_serialize_database().\n      This should be the same value as that returned by @ref\n      hs_serialize_database().\n\n @param db\n      Pointer to an 8-byte aligned block of memory of sufficient size to hold\n      the deserialized database. On success, the reconstructed database will\n      be written to this location. This database can then be used for pattern\n      matching. The user is responsible for freeing this memory; the @ref\n      hs_free_database() call should not be used.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_deserialize_database_at(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        db: *mut hs_database_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Provides the size of the stream state allocated by a single stream opened\n against the given database.\n\n @param database\n      Pointer to a compiled (streaming mode) pattern database.\n\n @param stream_size\n      On success, the size in bytes of an individual stream opened against the\n      given database is placed in this parameter.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_stream_size(database: *const hs_database_t, stream_size: *mut usize) -> hs_error_t;
}
extern "C" {
    #[doc = " Provides the size of the given database in bytes.\n\n @param database\n      Pointer to compiled pattern database.\n\n @param database_size\n      On success, the size of the compiled database in bytes is placed in this\n      parameter.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_database_size(
        database: *const hs_database_t,
        database_size: *mut usize,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Utility function for reporting the size that would be required by a\n database if it were deserialized.\n\n This can be used to allocate a shared memory region or other \"special\"\n allocation prior to deserializing with the @ref hs_deserialize_database_at()\n function.\n\n @param bytes\n      Pointer to a byte array generated by @ref hs_serialize_database()\n      representing a compiled pattern database.\n\n @param length\n      The length of the byte array generated by @ref hs_serialize_database().\n      This should be the same value as that returned by @ref\n      hs_serialize_database().\n\n @param deserialized_size\n      On success, the size of the compiled database that would be generated\n      by @ref hs_deserialize_database_at() is returned here.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_serialized_database_size(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        deserialized_size: *mut usize,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Utility function providing information about a database.\n\n @param database\n      Pointer to a compiled database.\n\n @param info\n      On success, a string containing the version and platform information for\n      the supplied database is placed in the parameter. The string is\n      allocated using the allocator supplied in @ref hs_set_misc_allocator()\n      (or malloc() if no allocator was set) and should be freed by the caller.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_database_info(
        database: *const hs_database_t,
        info: *mut *mut ::std::os::raw::c_char,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Utility function providing information about a serialized database.\n\n @param bytes\n      Pointer to a serialized database.\n\n @param length\n      Length in bytes of the serialized database.\n\n @param info\n      On success, a string containing the version and platform information\n      for the supplied serialized database is placed in the parameter. The\n      string is allocated using the allocator supplied in @ref\n      hs_set_misc_allocator() (or malloc() if no allocator was set) and\n      should be freed by the caller.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_serialized_database_info(
        bytes: *const ::std::os::raw::c_char,
        length: usize,
        info: *mut *mut ::std::os::raw::c_char,
    ) -> hs_error_t;
}
#[doc = " The type of the callback function that will be used by Hyperscan to allocate\n more memory at runtime as required, for example in @ref hs_open_stream() to\n allocate stream state.\n\n If Hyperscan is to be used in a multi-threaded, or similarly concurrent\n environment, the allocation function will need to be re-entrant, or\n similarly safe for concurrent use.\n\n @param size\n      The number of bytes to allocate.\n @return\n      A pointer to the region of memory allocated, or NULL on error."]
pub type hs_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
#[doc = " The type of the callback function that will be used by Hyperscan to free\n memory regions previously allocated using the @ref hs_alloc_t function.\n\n @param ptr\n      The region of memory to be freed."]
pub type hs_free_t = ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Set the allocate and free functions used by Hyperscan for allocating\n memory at runtime for stream state, scratch space, database bytecode,\n and various other data structure returned by the Hyperscan API.\n\n The function is equivalent to calling @ref hs_set_stream_allocator(),\n @ref hs_set_scratch_allocator(), @ref hs_set_database_allocator() and\n @ref hs_set_misc_allocator() with the provided parameters.\n\n This call will override any previous allocators that have been set.\n\n Note: there is no way to change the allocator used for temporary objects\n created during the various compile calls (@ref hs_compile(), @ref\n hs_compile_multi(), @ref hs_compile_ext_multi()).\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_set_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Set the allocate and free functions used by Hyperscan for allocating memory\n for database bytecode produced by the compile calls (@ref hs_compile(), @ref\n hs_compile_multi(), @ref hs_compile_ext_multi()) and by database\n deserialization (@ref hs_deserialize_database()).\n\n If no database allocation functions are set, or if NULL is used in place of\n both parameters, then memory allocation will default to standard methods\n (such as the system malloc() and free() calls).\n\n This call will override any previous database allocators that have been set.\n\n Note: the database allocator may also be set by calling @ref\n hs_set_allocator().\n\n Note: there is no way to change how temporary objects created during the\n various compile calls (@ref hs_compile(), @ref hs_compile_multi(), @ref\n hs_compile_ext_multi()) are allocated.\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_set_database_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Set the allocate and free functions used by Hyperscan for allocating memory\n for items returned by the Hyperscan API such as @ref hs_compile_error_t, @ref\n hs_expr_info_t and serialized databases.\n\n If no misc allocation functions are set, or if NULL is used in place of both\n parameters, then memory allocation will default to standard methods (such as\n the system malloc() and free() calls).\n\n This call will override any previous misc allocators that have been set.\n\n Note: the misc allocator may also be set by calling @ref hs_set_allocator().\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_set_misc_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Set the allocate and free functions used by Hyperscan for allocating memory\n for scratch space by @ref hs_alloc_scratch() and @ref hs_clone_scratch().\n\n If no scratch allocation functions are set, or if NULL is used in place of\n both parameters, then memory allocation will default to standard methods\n (such as the system malloc() and free() calls).\n\n This call will override any previous scratch allocators that have been set.\n\n Note: the scratch allocator may also be set by calling @ref\n hs_set_allocator().\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_set_scratch_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Set the allocate and free functions used by Hyperscan for allocating memory\n for stream state by @ref hs_open_stream().\n\n If no stream allocation functions are set, or if NULL is used in place of\n both parameters, then memory allocation will default to standard methods\n (such as the system malloc() and free() calls).\n\n This call will override any previous stream allocators that have been set.\n\n Note: the stream allocator may also be set by calling @ref\n hs_set_allocator().\n\n @param alloc_func\n      A callback function pointer that allocates memory. This function must\n      return memory suitably aligned for the largest representable data type\n      on this platform.\n\n @param free_func\n      A callback function pointer that frees allocated memory.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_set_stream_allocator(alloc_func: hs_alloc_t, free_func: hs_free_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Utility function for identifying this release version.\n\n @return\n      A string containing the version number of this release build and the\n      date of the build. It is allocated statically, so it does not need to\n      be freed by the caller."]
    pub fn hs_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Utility function to test the current system architecture.\n\n Hyperscan requires the Supplemental Streaming SIMD Extensions 3 instruction\n set. This function can be called on any x86 platform to determine if the\n system provides the required instruction set.\n\n This function does not test for more advanced features if Hyperscan has\n been built for a more specific architecture, for example the AVX2\n instruction set.\n\n @return\n      @ref HS_SUCCESS on success, @ref HS_ARCH_ERROR if system does not\n      support Hyperscan."]
    pub fn hs_valid_platform() -> hs_error_t;
}
#[doc = " A type containing error details that is returned by the compile calls (@ref\n hs_compile(), @ref hs_compile_multi() and @ref hs_compile_ext_multi()) on\n failure. The caller may inspect the values returned in this type to\n determine the cause of failure.\n\n Common errors generated during the compile process include:\n\n    - *Invalid parameter*\n\n      An invalid argument was specified in the compile call.\n\n    - *Unrecognised flag*\n\n      An unrecognised value was passed in the flags argument.\n\n    - *Pattern matches empty buffer*\n\n      By default, Hyperscan only supports patterns that will *always*\n      consume at least one byte of input. Patterns that do not have this\n      property (such as `/(abc)?/`) will produce this error unless\n      the @ref HS_FLAG_ALLOWEMPTY flag is supplied. Note that such\n      patterns will produce a match for *every* byte when scanned.\n\n    - *Embedded anchors not supported*\n\n      Hyperscan only supports the use of anchor meta-characters (such as\n      `^` and `$`) in patterns where they could *only* match\n      at the start or end of a buffer. A pattern containing an embedded\n      anchor, such as `/abc^def/`, can never match, as there is no\n      way for `abc` to precede the start of the data stream.\n\n    - *Bounded repeat is too large*\n\n      The pattern contains a repeated construct with very large finite\n      bounds.\n\n    - *Unsupported component type*\n\n      An unsupported PCRE construct was used in the pattern.\n\n    - *Unable to generate bytecode*\n\n      This error indicates that Hyperscan was unable to compile a pattern\n      that is syntactically valid. The most common cause is a pattern that is\n      very long and complex or contains a large repeated subpattern.\n\n    - *Unable to allocate memory*\n\n      The library was unable to allocate temporary storage used during\n      compilation time.\n\n    - *Allocator returned misaligned memory*\n\n      The memory allocator (either malloc() or the allocator set with @ref\n      hs_set_allocator()) did not correctly return memory suitably aligned\n      for the largest representable data type on this platform.\n\n    - *Internal error*\n\n      An unexpected error occurred: if this error is reported, please contact\n      the Hyperscan team with a description of the situation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_compile_error {
    #[doc = " A human-readable error message describing the error."]
    pub message: *mut ::std::os::raw::c_char,
    #[doc = " The zero-based number of the expression that caused the error (if this\n can be determined). If the error is not specific to an expression, then\n this value will be less than zero."]
    pub expression: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_hs_compile_error() {
    const UNINIT: ::std::mem::MaybeUninit<hs_compile_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hs_compile_error>(),
        16usize,
        concat!("Size of: ", stringify!(hs_compile_error))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_compile_error>(),
        8usize,
        concat!("Alignment of ", stringify!(hs_compile_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hs_compile_error), "::", stringify!(message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expression) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(hs_compile_error), "::", stringify!(expression))
    );
}
#[doc = " A type containing error details that is returned by the compile calls (@ref\n hs_compile(), @ref hs_compile_multi() and @ref hs_compile_ext_multi()) on\n failure. The caller may inspect the values returned in this type to\n determine the cause of failure.\n\n Common errors generated during the compile process include:\n\n    - *Invalid parameter*\n\n      An invalid argument was specified in the compile call.\n\n    - *Unrecognised flag*\n\n      An unrecognised value was passed in the flags argument.\n\n    - *Pattern matches empty buffer*\n\n      By default, Hyperscan only supports patterns that will *always*\n      consume at least one byte of input. Patterns that do not have this\n      property (such as `/(abc)?/`) will produce this error unless\n      the @ref HS_FLAG_ALLOWEMPTY flag is supplied. Note that such\n      patterns will produce a match for *every* byte when scanned.\n\n    - *Embedded anchors not supported*\n\n      Hyperscan only supports the use of anchor meta-characters (such as\n      `^` and `$`) in patterns where they could *only* match\n      at the start or end of a buffer. A pattern containing an embedded\n      anchor, such as `/abc^def/`, can never match, as there is no\n      way for `abc` to precede the start of the data stream.\n\n    - *Bounded repeat is too large*\n\n      The pattern contains a repeated construct with very large finite\n      bounds.\n\n    - *Unsupported component type*\n\n      An unsupported PCRE construct was used in the pattern.\n\n    - *Unable to generate bytecode*\n\n      This error indicates that Hyperscan was unable to compile a pattern\n      that is syntactically valid. The most common cause is a pattern that is\n      very long and complex or contains a large repeated subpattern.\n\n    - *Unable to allocate memory*\n\n      The library was unable to allocate temporary storage used during\n      compilation time.\n\n    - *Allocator returned misaligned memory*\n\n      The memory allocator (either malloc() or the allocator set with @ref\n      hs_set_allocator()) did not correctly return memory suitably aligned\n      for the largest representable data type on this platform.\n\n    - *Internal error*\n\n      An unexpected error occurred: if this error is reported, please contact\n      the Hyperscan team with a description of the situation."]
pub type hs_compile_error_t = hs_compile_error;
#[doc = " A type containing information on the target platform which may optionally be\n provided to the compile calls (@ref hs_compile(), @ref hs_compile_multi(),\n @ref hs_compile_ext_multi()).\n\n A hs_platform_info structure may be populated for the current platform by\n using the @ref hs_populate_platform() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_platform_info {
    #[doc = " Information about the target platform which may be used to guide the\n optimisation process of the compile.\n\n Use of this field does not limit the processors that the resulting\n database can run on, but may impact the performance of the resulting\n database."]
    pub tune: ::std::os::raw::c_uint,
    #[doc = " Relevant CPU features available on the target platform\n\n This value may be produced by combining HS_CPU_FEATURE_* flags (such as\n @ref HS_CPU_FEATURES_AVX2). Multiple CPU features may be or'ed together\n to produce the value."]
    pub cpu_features: ::std::os::raw::c_ulonglong,
    #[doc = " Reserved for future use."]
    pub reserved1: ::std::os::raw::c_ulonglong,
    #[doc = " Reserved for future use."]
    pub reserved2: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hs_platform_info() {
    const UNINIT: ::std::mem::MaybeUninit<hs_platform_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hs_platform_info>(),
        32usize,
        concat!("Size of: ", stringify!(hs_platform_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_platform_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hs_platform_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tune) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hs_platform_info), "::", stringify!(tune))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_platform_info),
            "::",
            stringify!(cpu_features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(hs_platform_info), "::", stringify!(reserved1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(hs_platform_info), "::", stringify!(reserved2))
    );
}
#[doc = " A type containing information on the target platform which may optionally be\n provided to the compile calls (@ref hs_compile(), @ref hs_compile_multi(),\n @ref hs_compile_ext_multi()).\n\n A hs_platform_info structure may be populated for the current platform by\n using the @ref hs_populate_platform() call."]
pub type hs_platform_info_t = hs_platform_info;
#[doc = " A type containing information related to an expression that is returned by\n @ref hs_expression_info() or @ref hs_expression_ext_info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_expr_info {
    #[doc = " The minimum length in bytes of a match for the pattern.\n\n Note: in some cases when using advanced features to suppress matches\n (such as extended parameters or the @ref HS_FLAG_SINGLEMATCH flag) this\n may represent a conservative lower bound for the true minimum length of\n a match."]
    pub min_width: ::std::os::raw::c_uint,
    #[doc = " The maximum length in bytes of a match for the pattern. If the pattern\n has an unbounded maximum length, this will be set to the maximum value\n of an unsigned int (UINT_MAX).\n\n Note: in some cases when using advanced features to suppress matches\n (such as extended parameters or the @ref HS_FLAG_SINGLEMATCH flag) this\n may represent a conservative upper bound for the true maximum length of\n a match."]
    pub max_width: ::std::os::raw::c_uint,
    #[doc = " Whether this expression can produce matches that are not returned in\n order, such as those produced by assertions. Zero if false, non-zero if\n true."]
    pub unordered_matches: ::std::os::raw::c_char,
    #[doc = " Whether this expression can produce matches at end of data (EOD). In\n streaming mode, EOD matches are raised during @ref hs_close_stream(),\n since it is only when @ref hs_close_stream() is called that the EOD\n location is known. Zero if false, non-zero if true.\n\n Note: trailing `\\b` word boundary assertions may also result in EOD\n matches as end-of-data can act as a word boundary."]
    pub matches_at_eod: ::std::os::raw::c_char,
    #[doc = " Whether this expression can *only* produce matches at end of data (EOD).\n In streaming mode, all matches for this expression are raised during\n @ref hs_close_stream(). Zero if false, non-zero if true."]
    pub matches_only_at_eod: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hs_expr_info() {
    const UNINIT: ::std::mem::MaybeUninit<hs_expr_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hs_expr_info>(),
        12usize,
        concat!("Size of: ", stringify!(hs_expr_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_expr_info>(),
        4usize,
        concat!("Alignment of ", stringify!(hs_expr_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_width) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hs_expr_info), "::", stringify!(min_width))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(hs_expr_info), "::", stringify!(max_width))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unordered_matches) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_info),
            "::",
            stringify!(unordered_matches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matches_at_eod) as usize - ptr as usize },
        9usize,
        concat!("Offset of field: ", stringify!(hs_expr_info), "::", stringify!(matches_at_eod))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matches_only_at_eod) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hs_expr_info),
            "::",
            stringify!(matches_only_at_eod)
        )
    );
}
#[doc = " A type containing information related to an expression that is returned by\n @ref hs_expression_info() or @ref hs_expression_ext_info."]
pub type hs_expr_info_t = hs_expr_info;
#[doc = " A structure containing additional parameters related to an expression,\n passed in at build time to @ref hs_compile_ext_multi() or @ref\n hs_expression_ext_info.\n\n These parameters allow the set of matches produced by a pattern to be\n constrained at compile time, rather than relying on the application to\n process unwanted matches at runtime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_expr_ext {
    #[doc = " Flags governing which parts of this structure are to be used by the\n compiler. See @ref HS_EXT_FLAG."]
    pub flags: ::std::os::raw::c_ulonglong,
    #[doc = " The minimum end offset in the data stream at which this expression\n should match successfully. To use this parameter, set the\n @ref HS_EXT_FLAG_MIN_OFFSET flag in the hs_expr_ext::flags field."]
    pub min_offset: ::std::os::raw::c_ulonglong,
    #[doc = " The maximum end offset in the data stream at which this expression\n should match successfully. To use this parameter, set the\n @ref HS_EXT_FLAG_MAX_OFFSET flag in the hs_expr_ext::flags field."]
    pub max_offset: ::std::os::raw::c_ulonglong,
    #[doc = " The minimum match length (from start to end) required to successfully\n match this expression. To use this parameter, set the\n @ref HS_EXT_FLAG_MIN_LENGTH flag in the hs_expr_ext::flags field."]
    pub min_length: ::std::os::raw::c_ulonglong,
    #[doc = " Allow patterns to approximately match within this edit distance. To use\n this parameter, set the @ref HS_EXT_FLAG_EDIT_DISTANCE flag in the\n hs_expr_ext::flags field."]
    pub edit_distance: ::std::os::raw::c_uint,
    #[doc = " Allow patterns to approximately match within this Hamming distance. To\n use this parameter, set the @ref HS_EXT_FLAG_HAMMING_DISTANCE flag in the\n hs_expr_ext::flags field."]
    pub hamming_distance: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hs_expr_ext() {
    const UNINIT: ::std::mem::MaybeUninit<hs_expr_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hs_expr_ext>(),
        40usize,
        concat!("Size of: ", stringify!(hs_expr_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<hs_expr_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(hs_expr_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hs_expr_ext), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_offset) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(hs_expr_ext), "::", stringify!(min_offset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_offset) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(hs_expr_ext), "::", stringify!(max_offset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_length) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(hs_expr_ext), "::", stringify!(min_length))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edit_distance) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(hs_expr_ext), "::", stringify!(edit_distance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hamming_distance) as usize - ptr as usize },
        36usize,
        concat!("Offset of field: ", stringify!(hs_expr_ext), "::", stringify!(hamming_distance))
    );
}
#[doc = " A structure containing additional parameters related to an expression,\n passed in at build time to @ref hs_compile_ext_multi() or @ref\n hs_expression_ext_info.\n\n These parameters allow the set of matches produced by a pattern to be\n constrained at compile time, rather than relying on the application to\n process unwanted matches at runtime."]
pub type hs_expr_ext_t = hs_expr_ext;
extern "C" {
    #[doc = " The basic regular expression compiler.\n\n This is the function call with which an expression is compiled into a\n Hyperscan database which can be passed to the runtime functions (such as\n @ref hs_scan(), @ref hs_open_stream(), etc.)\n\n @param expression\n      The NULL-terminated expression to parse. Note that this string must\n      represent ONLY the pattern to be matched, with no delimiters or flags;\n      any global flags should be specified with the @p flags argument. For\n      example, the expression `/abc?def/i` should be compiled by providing\n      `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a\n      flags.\n\n @param flags\n      Flags which modify the behaviour of the expression. Multiple flags may\n      be used by ORing them together. Valid values are:\n       - HS_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - HS_FLAG_SINGLEMATCH - Only one match will be generated for the\n                               expression per stream.\n       - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an\n                              empty string, such as `.*`.\n       - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - HS_FLAG_UCP - Use Unicode properties for character classes.\n       - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.\n       - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset\n                                when a match is found.\n       - HS_FLAG_COMBINATION - Parse the expression in logical combination\n                               syntax.\n       - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for\n                         the sub-expressions in logical combinations.\n\n @param mode\n      Compiler mode flags that affect the database as a whole. One of @ref\n      HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be\n      supplied, to select between the generation of a streaming, block or\n      vectored database. In addition, other flags (beginning with HS_MODE_)\n      may be supplied to enable specific features. See @ref HS_MODE_FLAG for\n      more details.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref hs_free_database() function.\n\n @param error\n      If the compile fails, a pointer to a @ref hs_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      hs_free_compile_error() function.\n\n @return\n      @ref HS_SUCCESS is returned on successful compilation; @ref\n      HS_COMPILER_ERROR on failure, with details provided in the error\n      parameter."]
    pub fn hs_compile(
        expression: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " The multiple regular expression compiler.\n\n This is the function call with which a set of expressions is compiled into a\n database which can be passed to the runtime functions (such as @ref\n hs_scan(), @ref hs_open_stream(), etc.) Each expression can be labelled with\n a unique integer which is passed into the match callback to identify the\n pattern that has matched.\n\n @param expressions\n      Array of NULL-terminated expressions to compile. Note that (as for @ref\n      hs_compile()) these strings must contain only the pattern to be\n      matched, with no delimiters or flags. For example, the expression\n      `/abc?def/i` should be compiled by providing `abc?def` as the first\n      string in the @p expressions array, and @ref HS_FLAG_CASELESS as the\n      first value in the @p flags array.\n\n @param flags\n      Array of flags which modify the behaviour of each expression. Multiple\n      flags may be used by ORing them together.  Specifying the NULL pointer\n      in place of an array will set the flags value for all patterns to zero.\n      Valid values are:\n       - HS_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - HS_FLAG_SINGLEMATCH - Only one match will be generated by patterns\n                               with this match id per stream.\n       - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an\n                              empty string, such as `.*`.\n       - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - HS_FLAG_UCP - Use Unicode properties for character classes.\n       - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.\n       - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset\n                                when a match is found.\n       - HS_FLAG_COMBINATION - Parse the expression in logical combination\n                               syntax.\n       - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for\n                         the sub-expressions in logical combinations.\n\n @param ids\n      An array of integers specifying the ID number to be associated with the\n      corresponding pattern in the expressions array. Specifying the NULL\n      pointer in place of an array will set the ID value for all patterns to\n      zero.\n\n @param elements\n      The number of elements in the input arrays.\n\n @param mode\n      Compiler mode flags that affect the database as a whole. One of @ref\n      HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be\n      supplied, to select between the generation of a streaming, block or\n      vectored database. In addition, other flags (beginning with HS_MODE_)\n      may be supplied to enable specific features. See @ref HS_MODE_FLAG for\n      more details.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref hs_free_database() function.\n\n @param error\n      If the compile fails, a pointer to a @ref hs_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      hs_free_compile_error() function.\n\n @return\n      @ref HS_SUCCESS is returned on successful compilation; @ref\n      HS_COMPILER_ERROR on failure, with details provided in the @p error\n      parameter.\n"]
    pub fn hs_compile_multi(
        expressions: *const *const ::std::os::raw::c_char,
        flags: *const ::std::os::raw::c_uint,
        ids: *const ::std::os::raw::c_uint,
        elements: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " The multiple regular expression compiler with extended parameter support.\n\n This function call compiles a group of expressions into a database in the\n same way as @ref hs_compile_multi(), but allows additional parameters to be\n specified via an @ref hs_expr_ext_t structure per expression.\n\n @param expressions\n      Array of NULL-terminated expressions to compile. Note that (as for @ref\n      hs_compile()) these strings must contain only the pattern to be\n      matched, with no delimiters or flags. For example, the expression\n      `/abc?def/i` should be compiled by providing `abc?def` as the first\n      string in the @p expressions array, and @ref HS_FLAG_CASELESS as the\n      first value in the @p flags array.\n\n @param flags\n      Array of flags which modify the behaviour of each expression. Multiple\n      flags may be used by ORing them together. Specifying the NULL pointer\n      in place of an array will set the flags value for all patterns to zero.\n      Valid values are:\n       - HS_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - HS_FLAG_SINGLEMATCH - Only one match will be generated by patterns\n                               with this match id per stream.\n       - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an\n                              empty string, such as `.*`.\n       - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - HS_FLAG_UCP - Use Unicode properties for character classes.\n       - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.\n       - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset\n                                when a match is found.\n       - HS_FLAG_COMBINATION - Parse the expression in logical combination\n                               syntax.\n       - HS_FLAG_QUIET - Ignore match reporting for this expression. Used for\n                         the sub-expressions in logical combinations.\n\n @param ids\n      An array of integers specifying the ID number to be associated with the\n      corresponding pattern in the expressions array. Specifying the NULL\n      pointer in place of an array will set the ID value for all patterns to\n      zero.\n\n @param ext\n      An array of pointers to filled @ref hs_expr_ext_t structures that\n      define extended behaviour for each pattern. NULL may be specified if no\n      extended behaviour is needed for an individual pattern, or in place of\n      the whole array if it is not needed for any expressions. Memory used by\n      these structures must be both allocated and freed by the caller.\n\n @param elements\n      The number of elements in the input arrays.\n\n @param mode\n      Compiler mode flags that affect the database as a whole. One of @ref\n      HS_MODE_STREAM, @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be\n      supplied, to select between the generation of a streaming, block or\n      vectored database. In addition, other flags (beginning with HS_MODE_)\n      may be supplied to enable specific features. See @ref HS_MODE_FLAG for\n      more details.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref hs_free_database() function.\n\n @param error\n      If the compile fails, a pointer to a @ref hs_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      hs_free_compile_error() function.\n\n @return\n      @ref HS_SUCCESS is returned on successful compilation; @ref\n      HS_COMPILER_ERROR on failure, with details provided in the @p error\n      parameter.\n"]
    pub fn hs_compile_ext_multi(
        expressions: *const *const ::std::os::raw::c_char,
        flags: *const ::std::os::raw::c_uint,
        ids: *const ::std::os::raw::c_uint,
        ext: *const *const hs_expr_ext_t,
        elements: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " The basic pure literal expression compiler.\n\n This is the function call with which a pure literal expression (not a\n common regular expression) is compiled into a Hyperscan database which\n can be passed to the runtime functions (such as @ref hs_scan(),\n @ref hs_open_stream(), etc.)\n\n @param expression\n      The NULL-terminated expression to parse. Note that this string must\n      represent ONLY the pattern to be matched, with no delimiters or flags;\n      any global flags should be specified with the @p flags argument. For\n      example, the expression `/abc?def/i` should be compiled by providing\n      `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a\n      flags. Meanwhile, the string content shall be fully parsed in a literal\n      sense without any regular grammars. For example, the @p expression\n      `abc?` simply means a char sequence of `a`, `b`, `c`, and `?`. The `?`\n      here doesn't mean 0 or 1 quantifier under regular semantics.\n\n @param flags\n      Flags which modify the behaviour of the expression. Multiple flags may\n      be used by ORing them together. Compared to @ref hs_compile(), fewer\n      valid values are provided:\n       - HS_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - HS_FLAG_SINGLEMATCH - Only one match will be generated for the\n                               expression per stream.\n       - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset\n                                when a match is found.\n\n @param len\n      The length of the text content of the pure literal expression. As the\n      text content indicated by @p expression is treated as single character\n      one by one, the special terminating character `\\0` should be allowed\n      to appear in expression, and not treated as a terminator for a string.\n      Thus, the end of a pure literal expression cannot be indicated by\n      identifying `\\0`, but by counting to the expression length.\n\n @param mode\n      Compiler mode flags that affect the database as a whole. One of @ref\n      HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be\n      supplied, to select between the generation of a streaming, block or\n      vectored database. In addition, other flags (beginning with HS_MODE_)\n      may be supplied to enable specific features. See @ref HS_MODE_FLAG for\n      more details.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref hs_free_database() function.\n\n @param error\n      If the compile fails, a pointer to a @ref hs_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      hs_free_compile_error() function.\n\n @return\n      @ref HS_SUCCESS is returned on successful compilation; @ref\n      HS_COMPILER_ERROR on failure, with details provided in the error\n      parameter."]
    pub fn hs_compile_lit(
        expression: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        len: usize,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " The multiple pure literal expression compiler.\n\n This is the function call with which a set of pure literal expressions is\n compiled into a database which can be passed to the runtime functions (such\n as @ref hs_scan(), @ref hs_open_stream(), etc.) Each expression can be\n labelled with a unique integer which is passed into the match callback to\n identify the pattern that has matched.\n\n @param expressions\n      The NULL-terminated expression to parse. Note that this string must\n      represent ONLY the pattern to be matched, with no delimiters or flags;\n      any global flags should be specified with the @p flags argument. For\n      example, the expression `/abc?def/i` should be compiled by providing\n      `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a\n      flags. Meanwhile, the string content shall be fully parsed in a literal\n      sense without any regular grammars. For example, the @p expression\n      `abc?` simply means a char sequence of `a`, `b`, `c`, and `?`. The `?`\n      here doesn't mean 0 or 1 quantifier under regular semantics.\n\n @param flags\n      Array of flags which modify the behaviour of each expression. Multiple\n      flags may be used by ORing them together. Specifying the NULL pointer\n      in place of an array will set the flags value for all patterns to zero.\n      Compared to @ref hs_compile_multi(), fewer valid values are provided:\n       - HS_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - HS_FLAG_SINGLEMATCH - Only one match will be generated for the\n                               expression per stream.\n       - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset\n                                when a match is found.\n\n @param ids\n      An array of integers specifying the ID number to be associated with the\n      corresponding pattern in the expressions array. Specifying the NULL\n      pointer in place of an array will set the ID value for all patterns to\n      zero.\n\n @param lens\n      Array of lengths of the text content of each pure literal expression.\n      As the text content indicated by @p expression is treated as single\n      character one by one, the special terminating character `\\0` should be\n      allowed to appear in expression, and not treated as a terminator for a\n      string. Thus, the end of a pure literal expression cannot be indicated\n      by identifying `\\0`, but by counting to the expression length.\n\n @param elements\n      The number of elements in the input arrays.\n\n @param mode\n      Compiler mode flags that affect the database as a whole. One of @ref\n      HS_MODE_STREAM or @ref HS_MODE_BLOCK or @ref HS_MODE_VECTORED must be\n      supplied, to select between the generation of a streaming, block or\n      vectored database. In addition, other flags (beginning with HS_MODE_)\n      may be supplied to enable specific features. See @ref HS_MODE_FLAG for\n      more details.\n\n @param platform\n      If not NULL, the platform structure is used to determine the target\n      platform for the database. If NULL, a database suitable for running\n      on the current host platform is produced.\n\n @param db\n      On success, a pointer to the generated database will be returned in\n      this parameter, or NULL on failure. The caller is responsible for\n      deallocating the buffer using the @ref hs_free_database() function.\n\n @param error\n      If the compile fails, a pointer to a @ref hs_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      hs_free_compile_error() function.\n\n @return\n      @ref HS_SUCCESS is returned on successful compilation; @ref\n      HS_COMPILER_ERROR on failure, with details provided in the error\n      parameter."]
    pub fn hs_compile_lit_multi(
        expressions: *const *const ::std::os::raw::c_char,
        flags: *const ::std::os::raw::c_uint,
        ids: *const ::std::os::raw::c_uint,
        lens: *const usize,
        elements: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_uint,
        platform: *const hs_platform_info_t,
        db: *mut *mut hs_database_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Free an error structure generated by @ref hs_compile(), @ref\n hs_compile_multi() or @ref hs_compile_ext_multi().\n\n @param error\n      The @ref hs_compile_error_t to be freed. NULL may also be safely\n      provided.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_free_compile_error(error: *mut hs_compile_error_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Utility function providing information about a regular expression. The\n information provided in @ref hs_expr_info_t includes the minimum and maximum\n width of a pattern match.\n\n Note: successful analysis of an expression with this function does not imply\n that compilation of the same expression (via @ref hs_compile(), @ref\n hs_compile_multi() or @ref hs_compile_ext_multi()) would succeed. This\n function may return @ref HS_SUCCESS for regular expressions that Hyperscan\n cannot compile.\n\n Note: some per-pattern flags (such as @ref HS_FLAG_ALLOWEMPTY, @ref\n HS_FLAG_SOM_LEFTMOST) are accepted by this call, but as they do not affect\n the properties returned in the @ref hs_expr_info_t structure, they will not\n affect the outcome of this function.\n\n @param expression\n      The NULL-terminated expression to parse. Note that this string must\n      represent ONLY the pattern to be matched, with no delimiters or flags;\n      any global flags should be specified with the @p flags argument.  For\n      example, the expression `/abc?def/i` should be compiled by providing\n      `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a\n      flags.\n\n @param flags\n      Flags which modify the behaviour of the expression. Multiple flags may\n      be used by ORing them together. Valid values are:\n       - HS_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - HS_FLAG_SINGLEMATCH - Only one match will be generated by the\n                               expression per stream.\n       - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an\n                              empty string, such as `.*`.\n       - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - HS_FLAG_UCP - Use Unicode properties for character classes.\n       - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.\n       - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset\n                                when a match is found.\n       - HS_FLAG_QUIET - This flag will be ignored.\n\n @param info\n      On success, a pointer to the pattern information will be returned in\n      this parameter, or NULL on failure. This structure is allocated using\n      the allocator supplied in @ref hs_set_allocator() (or malloc() if no\n      allocator was set) and should be freed by the caller.\n\n @param error\n      If the call fails, a pointer to a @ref hs_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      hs_free_compile_error() function.\n\n @return\n      @ref HS_SUCCESS is returned on successful compilation; @ref\n      HS_COMPILER_ERROR on failure, with details provided in the error\n      parameter."]
    pub fn hs_expression_info(
        expression: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        info: *mut *mut hs_expr_info_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Utility function providing information about a regular expression, with\n extended parameter support. The information provided in @ref hs_expr_info_t\n includes the minimum and maximum width of a pattern match.\n\n Note: successful analysis of an expression with this function does not imply\n that compilation of the same expression (via @ref hs_compile(), @ref\n hs_compile_multi() or @ref hs_compile_ext_multi()) would succeed. This\n function may return @ref HS_SUCCESS for regular expressions that Hyperscan\n cannot compile.\n\n Note: some per-pattern flags (such as @ref HS_FLAG_ALLOWEMPTY, @ref\n HS_FLAG_SOM_LEFTMOST) are accepted by this call, but as they do not affect\n the properties returned in the @ref hs_expr_info_t structure, they will not\n affect the outcome of this function.\n\n @param expression\n      The NULL-terminated expression to parse. Note that this string must\n      represent ONLY the pattern to be matched, with no delimiters or flags;\n      any global flags should be specified with the @p flags argument.  For\n      example, the expression `/abc?def/i` should be compiled by providing\n      `abc?def` as the @p expression, and @ref HS_FLAG_CASELESS as the @a\n      flags.\n\n @param flags\n      Flags which modify the behaviour of the expression. Multiple flags may\n      be used by ORing them together. Valid values are:\n       - HS_FLAG_CASELESS - Matching will be performed case-insensitively.\n       - HS_FLAG_DOTALL - Matching a `.` will not exclude newlines.\n       - HS_FLAG_MULTILINE - `^` and `$` anchors match any newlines in data.\n       - HS_FLAG_SINGLEMATCH - Only one match will be generated by the\n                               expression per stream.\n       - HS_FLAG_ALLOWEMPTY - Allow expressions which can match against an\n                              empty string, such as `.*`.\n       - HS_FLAG_UTF8 - Treat this pattern as a sequence of UTF-8 characters.\n       - HS_FLAG_UCP - Use Unicode properties for character classes.\n       - HS_FLAG_PREFILTER - Compile pattern in prefiltering mode.\n       - HS_FLAG_SOM_LEFTMOST - Report the leftmost start of match offset\n                                when a match is found.\n       - HS_FLAG_QUIET - This flag will be ignored.\n\n @param ext\n      A pointer to a filled @ref hs_expr_ext_t structure that defines\n      extended behaviour for this pattern. NULL may be specified if no\n      extended parameters are needed.\n\n @param info\n      On success, a pointer to the pattern information will be returned in\n      this parameter, or NULL on failure. This structure is allocated using\n      the allocator supplied in @ref hs_set_allocator() (or malloc() if no\n      allocator was set) and should be freed by the caller.\n\n @param error\n      If the call fails, a pointer to a @ref hs_compile_error_t will be\n      returned, providing details of the error condition. The caller is\n      responsible for deallocating the buffer using the @ref\n      hs_free_compile_error() function.\n\n @return\n      @ref HS_SUCCESS is returned on successful compilation; @ref\n      HS_COMPILER_ERROR on failure, with details provided in the error\n      parameter."]
    pub fn hs_expression_ext_info(
        expression: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        ext: *const hs_expr_ext_t,
        info: *mut *mut hs_expr_info_t,
        error: *mut *mut hs_compile_error_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Populates the platform information based on the current host.\n\n @param platform\n      On success, the pointed to structure is populated based on the current\n      host.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_populate_platform(platform: *mut hs_platform_info_t) -> hs_error_t;
}
#[doc = " Definition of the stream identifier type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_stream {
    _unused: [u8; 0],
}
#[doc = " The stream identifier returned by @ref hs_open_stream()."]
pub type hs_stream_t = hs_stream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hs_scratch {
    _unused: [u8; 0],
}
#[doc = " A Hyperscan scratch space."]
pub type hs_scratch_t = hs_scratch;
#[doc = " Definition of the match event callback function type.\n\n A callback function matching the defined type must be provided by the\n application calling the @ref hs_scan(), @ref hs_scan_vector() or @ref\n hs_scan_stream() functions (or other streaming calls which can produce\n matches).\n\n This callback function will be invoked whenever a match is located in the\n target data during the execution of a scan. The details of the match are\n passed in as parameters to the callback function, and the callback function\n should return a value indicating whether or not matching should continue on\n the target data. If no callbacks are desired from a scan call, NULL may be\n provided in order to suppress match production.\n\n This callback function should not attempt to call Hyperscan API functions on\n the same stream nor should it attempt to reuse the scratch space allocated\n for the API calls that caused it to be triggered. Making another call to the\n Hyperscan library with completely independent parameters should work (for\n example, scanning a different database in a new stream and with new scratch\n space), but reusing data structures like stream state and/or scratch space\n will produce undefined behavior.\n\n @param id\n      The ID number of the expression that matched. If the expression was a\n      single expression compiled with @ref hs_compile(), this value will be\n      zero.\n\n @param from\n      - If a start of match flag is enabled for the current pattern, this\n        argument will be set to the start of match for the pattern assuming\n        that that start of match value lies within the current 'start of match\n        horizon' chosen by one of the SOM_HORIZON mode flags.\n\n      - If the start of match value lies outside this horizon (possible only\n        when the SOM_HORIZON value is not @ref HS_MODE_SOM_HORIZON_LARGE),\n        the @p from value will be set to @ref HS_OFFSET_PAST_HORIZON.\n\n      - This argument will be set to zero if the Start of Match flag is not\n        enabled for the given pattern.\n\n @param to\n      The offset after the last byte that matches the expression.\n\n @param flags\n      This is provided for future use and is unused at present.\n\n @param context\n      The pointer supplied by the user to the @ref hs_scan(), @ref\n      hs_scan_vector() or @ref hs_scan_stream() function.\n\n @return\n      Non-zero if the matching should cease, else zero. If scanning is\n      performed in streaming mode and a non-zero value is returned, any\n      subsequent calls to @ref hs_scan_stream() for that stream will\n      immediately return with @ref HS_SCAN_TERMINATED."]
pub type match_event_handler = ::std::option::Option<
    unsafe extern "C" fn(
        id: ::std::os::raw::c_uint,
        from: ::std::os::raw::c_ulonglong,
        to: ::std::os::raw::c_ulonglong,
        flags: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Open and initialise a stream.\n\n @param db\n      A compiled pattern database.\n\n @param flags\n      Flags modifying the behaviour of the stream. This parameter is provided\n      for future use and is unused at present.\n\n @param stream\n      On success, a pointer to the generated @ref hs_stream_t will be\n      returned; NULL on failure.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_open_stream(
        db: *const hs_database_t,
        flags: ::std::os::raw::c_uint,
        stream: *mut *mut hs_stream_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Write data to be scanned to the opened stream.\n\n This is the function call in which the actual pattern matching takes place\n as data is written to the stream. Matches will be returned via the @ref\n match_event_handler callback supplied.\n\n @param id\n      The stream ID (returned by @ref hs_open_stream()) to which the data\n      will be written.\n\n @param data\n      Pointer to the data to be scanned.\n\n @param length\n      The number of bytes to scan.\n\n @param flags\n      Flags modifying the behaviour of the stream. This parameter is provided\n      for future use and is unused at present.\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch().\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param ctxt\n      The user defined pointer which will be passed to the callback function\n      when a match occurs.\n\n @return\n      Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the\n      match callback indicated that scanning should stop; other values on\n      error."]
    pub fn hs_scan_stream(
        id: *mut hs_stream_t,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        ctxt: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Close a stream.\n\n This function completes matching on the given stream and frees the memory\n associated with the stream state. After this call, the stream pointed to by\n @p id is invalid and can no longer be used. To reuse the stream state after\n completion, rather than closing it, the @ref hs_reset_stream function can be\n used.\n\n This function must be called for any stream created with @ref\n hs_open_stream(), even if scanning has been terminated by a non-zero return\n from the match callback function.\n\n Note: This operation may result in matches being returned (via calls to the\n match event callback) for expressions anchored to the end of the data stream\n (for example, via the use of the `$` meta-character). If these matches are\n not desired, NULL may be provided as the @ref match_event_handler callback.\n\n If NULL is provided as the @ref match_event_handler callback, it is\n permissible to provide a NULL scratch.\n\n @param id\n      The stream ID returned by @ref hs_open_stream().\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is\n      allowed to be NULL only if the @p onEvent callback is also NULL.\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param ctxt\n      The user defined pointer which will be passed to the callback function\n      when a match occurs.\n\n @return\n      Returns @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_close_stream(
        id: *mut hs_stream_t,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        ctxt: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Reset a stream to an initial state.\n\n Conceptually, this is equivalent to performing @ref hs_close_stream() on the\n given stream, followed by a @ref hs_open_stream(). This new stream replaces\n the original stream in memory, avoiding the overhead of freeing the old\n stream and allocating the new one.\n\n Note: This operation may result in matches being returned (via calls to the\n match event callback) for expressions anchored to the end of the original\n data stream (for example, via the use of the `$` meta-character). If these\n matches are not desired, NULL may be provided as the @ref match_event_handler\n callback.\n\n Note: the stream will also be tied to the same database.\n\n @param id\n      The stream (as created by @ref hs_open_stream()) to be replaced.\n\n @param flags\n      Flags modifying the behaviour of the stream. This parameter is provided\n      for future use and is unused at present.\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is\n      allowed to be NULL only if the @p onEvent callback is also NULL.\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param context\n      The user defined pointer which will be passed to the callback function\n      when a match occurs.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_reset_stream(
        id: *mut hs_stream_t,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Duplicate the given stream. The new stream will have the same state as the\n original including the current stream offset.\n\n @param to_id\n      On success, a pointer to the new, copied @ref hs_stream_t will be\n      returned; NULL on failure.\n\n @param from_id\n      The stream (as created by @ref hs_open_stream()) to be copied.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_copy_stream(to_id: *mut *mut hs_stream_t, from_id: *const hs_stream_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Duplicate the given 'from' stream state onto the 'to' stream. The 'to' stream\n will first be reset (reporting any EOD matches if a non-NULL @p onEvent\n callback handler is provided).\n\n Note: the 'to' stream and the 'from' stream must be open against the same\n database.\n\n @param to_id\n      On success, a pointer to the new, copied @ref hs_stream_t will be\n      returned; NULL on failure.\n\n @param from_id\n      The stream (as created by @ref hs_open_stream()) to be copied.\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is\n      allowed to be NULL only if the @p onEvent callback is also NULL.\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param context\n      The user defined pointer which will be passed to the callback function\n      when a match occurs.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_reset_and_copy_stream(
        to_id: *mut hs_stream_t,
        from_id: *const hs_stream_t,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Creates a compressed representation of the provided stream in the buffer\n provided. This compressed representation can be converted back into a stream\n state by using @ref hs_expand_stream() or @ref hs_reset_and_expand_stream().\n The size of the compressed representation will be placed into @p used_space.\n\n If there is not sufficient space in the buffer to hold the compressed\n representation, @ref HS_INSUFFICIENT_SPACE will be returned and @p used_space\n will be populated with the amount of space required.\n\n Note: this function does not close the provided stream, you may continue to\n use the stream or to free it with @ref hs_close_stream().\n\n @param stream\n      The stream (as created by @ref hs_open_stream()) to be compressed.\n\n @param buf\n      Buffer to write the compressed representation into. Note: if the call is\n      just being used to determine the amount of space required, it is allowed\n      to pass NULL here and @p buf_space as 0.\n\n @param buf_space\n      The number of bytes in @p buf. If buf_space is too small, the call will\n      fail with @ref HS_INSUFFICIENT_SPACE.\n\n @param used_space\n      Pointer to where the amount of used space will be written to. The used\n      buffer space is always less than or equal to @p buf_space. If the call\n      fails with @ref HS_INSUFFICIENT_SPACE, this pointer will be used to\n      write out the amount of buffer space required.\n\n @return\n      @ref HS_SUCCESS on success, @ref HS_INSUFFICIENT_SPACE if the provided\n      buffer is too small."]
    pub fn hs_compress_stream(
        stream: *const hs_stream_t,
        buf: *mut ::std::os::raw::c_char,
        buf_space: usize,
        used_space: *mut usize,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Decompresses a compressed representation created by @ref hs_compress_stream()\n into a new stream.\n\n Note: @p buf must correspond to a complete compressed representation created\n by @ref hs_compress_stream() of a stream that was opened against @p db. It is\n not always possible to detect misuse of this API and behaviour is undefined\n if these properties are not satisfied.\n\n @param db\n      The compiled pattern database that the compressed stream was opened\n      against.\n\n @param stream\n      On success, a pointer to the expanded @ref hs_stream_t will be\n      returned; NULL on failure.\n\n @param buf\n      A compressed representation of a stream. These compressed forms are\n      created by @ref hs_compress_stream().\n\n @param buf_size\n      The size in bytes of the compressed representation.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_expand_stream(
        db: *const hs_database_t,
        stream: *mut *mut hs_stream_t,
        buf: *const ::std::os::raw::c_char,
        buf_size: usize,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Decompresses a compressed representation created by @ref hs_compress_stream()\n on top of the 'to' stream. The 'to' stream will first be reset (reporting\n any EOD matches if a non-NULL @p onEvent callback handler is provided).\n\n Note: the 'to' stream must be opened against the same database as the\n compressed stream.\n\n Note: @p buf must correspond to a complete compressed representation created\n by @ref hs_compress_stream() of a stream that was opened against @p db. It is\n not always possible to detect misuse of this API and behaviour is undefined\n if these properties are not satisfied.\n\n @param to_stream\n      A pointer to a valid stream state. A pointer to the expanded @ref\n      hs_stream_t will be returned; NULL on failure.\n\n @param buf\n      A compressed representation of a stream. These compressed forms are\n      created by @ref hs_compress_stream().\n\n @param buf_size\n      The size in bytes of the compressed representation.\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch(). This is\n      allowed to be NULL only if the @p onEvent callback is also NULL.\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param context\n      The user defined pointer which will be passed to the callback function\n      when a match occurs.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_reset_and_expand_stream(
        to_stream: *mut hs_stream_t,
        buf: *const ::std::os::raw::c_char,
        buf_size: usize,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " The block (non-streaming) regular expression scanner.\n\n This is the function call in which the actual pattern matching takes place\n for block-mode pattern databases.\n\n @param db\n      A compiled pattern database.\n\n @param data\n      Pointer to the data to be scanned.\n\n @param length\n      The number of bytes to scan.\n\n @param flags\n      Flags modifying the behaviour of this function. This parameter is\n      provided for future use and is unused at present.\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch() for this\n      database.\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param context\n      The user defined pointer which will be passed to the callback function.\n\n @return\n      Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the\n      match callback indicated that scanning should stop; other values on\n      error."]
    pub fn hs_scan(
        db: *const hs_database_t,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " The vectored regular expression scanner.\n\n This is the function call in which the actual pattern matching takes place\n for vectoring-mode pattern databases.\n\n @param db\n      A compiled pattern database.\n\n @param data\n      An array of pointers to the data blocks to be scanned.\n\n @param length\n      An array of lengths (in bytes) of each data block to scan.\n\n @param count\n      Number of data blocks to scan. This should correspond to the size of\n      of the @p data and @p length arrays.\n\n @param flags\n      Flags modifying the behaviour of this function. This parameter is\n      provided for future use and is unused at present.\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch() for\n      this database.\n\n @param onEvent\n      Pointer to a match event callback function. If a NULL pointer is given,\n      no matches will be returned.\n\n @param context\n      The user defined pointer which will be passed to the callback function.\n\n @return\n      Returns @ref HS_SUCCESS on success; @ref HS_SCAN_TERMINATED if the match\n      callback indicated that scanning should stop; other values on error."]
    pub fn hs_scan_vector(
        db: *const hs_database_t,
        data: *const *const ::std::os::raw::c_char,
        length: *const ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        scratch: *mut hs_scratch_t,
        onEvent: match_event_handler,
        context: *mut ::std::os::raw::c_void,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Allocate a \"scratch\" space for use by Hyperscan.\n\n This is required for runtime use, and one scratch space per thread, or\n concurrent caller, is required. Any allocator callback set by @ref\n hs_set_scratch_allocator() or @ref hs_set_allocator() will be used by this\n function.\n\n @param db\n      The database, as produced by @ref hs_compile().\n\n @param scratch\n      On first allocation, a pointer to NULL should be provided so a new\n      scratch can be allocated. If a scratch block has been previously\n      allocated, then a pointer to it should be passed back in to see if it\n      is valid for this database block. If a new scratch block is required,\n      the original will be freed and the new one returned, otherwise the\n      previous scratch block will be returned. On success, the scratch block\n      will be suitable for use with the provided database in addition to any\n      databases that original scratch space was suitable for.\n\n @return\n      @ref HS_SUCCESS on successful allocation; @ref HS_NOMEM if the\n      allocation fails.  Other errors may be returned if invalid parameters\n      are specified."]
    pub fn hs_alloc_scratch(
        db: *const hs_database_t,
        scratch: *mut *mut hs_scratch_t,
    ) -> hs_error_t;
}
extern "C" {
    #[doc = " Allocate a scratch space that is a clone of an existing scratch space.\n\n This is useful when multiple concurrent threads will be using the same set\n of compiled databases, and another scratch space is required. Any allocator\n callback set by @ref hs_set_scratch_allocator() or @ref hs_set_allocator()\n will be used by this function.\n\n @param src\n      The existing @ref hs_scratch_t to be cloned.\n\n @param dest\n      A pointer to the new scratch space will be returned here.\n\n @return\n      @ref HS_SUCCESS on success; @ref HS_NOMEM if the allocation fails.\n      Other errors may be returned if invalid parameters are specified."]
    pub fn hs_clone_scratch(src: *const hs_scratch_t, dest: *mut *mut hs_scratch_t) -> hs_error_t;
}
extern "C" {
    #[doc = " Provides the size of the given scratch space.\n\n @param scratch\n      A per-thread scratch space allocated by @ref hs_alloc_scratch() or @ref\n      hs_clone_scratch().\n\n @param scratch_size\n      On success, the size of the scratch space in bytes is placed in this\n      parameter.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_scratch_size(scratch: *const hs_scratch_t, scratch_size: *mut usize) -> hs_error_t;
}
extern "C" {
    #[doc = " Free a scratch block previously allocated by @ref hs_alloc_scratch() or @ref\n hs_clone_scratch().\n\n The free callback set by @ref hs_set_scratch_allocator() or @ref\n hs_set_allocator() will be used by this function.\n\n @param scratch\n      The scratch block to be freed. NULL may also be safely provided.\n\n @return\n      @ref HS_SUCCESS on success, other values on failure."]
    pub fn hs_free_scratch(scratch: *mut hs_scratch_t) -> hs_error_t;
}
